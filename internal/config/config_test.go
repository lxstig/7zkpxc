package config

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/spf13/viper"
)

// resetViper clears all global viper state so tests are fully isolated.
func resetViper(t *testing.T) {
	t.Helper()
	viper.Reset()
}

func TestLoadConfig_Defaults(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	cfg, err := LoadConfig()
	if err != nil {
		t.Fatalf("LoadConfig() failed: %v", err)
	}

	if cfg.General.DefaultGroup != "Archives/AutoGenerated" {
		t.Errorf("DefaultGroup = %q, want %q", cfg.General.DefaultGroup, "Archives/AutoGenerated")
	}
	if cfg.General.UseKeyring != true {
		t.Errorf("UseKeyring = %v, want true", cfg.General.UseKeyring)
	}
	if cfg.General.PasswordLength != PasswordLengthDefault {
		t.Errorf("PasswordLength = %d, want %d", cfg.General.PasswordLength, PasswordLengthDefault)
	}
	if cfg.SevenZip.BinaryPath != "7z" {
		t.Errorf("BinaryPath = %q, want %q", cfg.SevenZip.BinaryPath, "7z")
	}
	if len(cfg.SevenZip.DefaultArgs) != 2 {
		t.Errorf("DefaultArgs len = %d, want 2", len(cfg.SevenZip.DefaultArgs))
	}
}

func TestLoadConfig_NoConfigFileIsNotAnError(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// No config file exists â€” should succeed with defaults
	_, err := LoadConfig()
	if err != nil {
		t.Fatalf("LoadConfig() should not fail when config file is missing: %v", err)
	}
}

func TestSaveConfig(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	cfg := &Config{
		General: GeneralConfig{
			KdbxPath:       "/path/to/test.kdbx",
			DefaultGroup:   "TestGroup",
			UseKeyring:     false,
			PasswordLength: 96,
		},
		SevenZip: SevenZipConfig{
			DefaultArgs: []string{"-mhe=on"},
			BinaryPath:  "7z",
		},
	}

	if err := SaveConfig(cfg); err != nil {
		t.Fatalf("SaveConfig() failed: %v", err)
	}

	// Verify file was created
	configPath := filepath.Join(tmpHome, ".config", "7zkpxc", "config.yaml")
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		t.Fatalf("Config file not created at %s", configPath)
	}
}

func TestSaveAndLoad_RoundTrip(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	original := &Config{
		General: GeneralConfig{
			KdbxPath:       "/home/user/passwords.kdbx",
			DefaultGroup:   "MyArchives/2026",
			UseKeyring:     false,
			PasswordLength: 96,
		},
		SevenZip: SevenZipConfig{
			DefaultArgs: []string{"-mhe=on", "-mx=5"},
			BinaryPath:  "/usr/bin/7z",
		},
	}

	if err := SaveConfig(original); err != nil {
		t.Fatalf("SaveConfig() failed: %v", err)
	}

	// Reset viper again so LoadConfig reads from file, not memory
	resetViper(t)

	loaded, err := LoadConfig()
	if err != nil {
		t.Fatalf("LoadConfig() after save failed: %v", err)
	}

	if loaded.General.KdbxPath != original.General.KdbxPath {
		t.Errorf("KdbxPath = %q, want %q", loaded.General.KdbxPath, original.General.KdbxPath)
	}
	if loaded.General.DefaultGroup != original.General.DefaultGroup {
		t.Errorf("DefaultGroup = %q, want %q", loaded.General.DefaultGroup, original.General.DefaultGroup)
	}
	if loaded.General.UseKeyring != original.General.UseKeyring {
		t.Errorf("UseKeyring = %v, want %v", loaded.General.UseKeyring, original.General.UseKeyring)
	}
	if loaded.General.PasswordLength != original.General.PasswordLength {
		t.Errorf("PasswordLength = %d, want %d", loaded.General.PasswordLength, original.General.PasswordLength)
	}
	if loaded.SevenZip.BinaryPath != original.SevenZip.BinaryPath {
		t.Errorf("BinaryPath = %q, want %q", loaded.SevenZip.BinaryPath, original.SevenZip.BinaryPath)
	}
	if len(loaded.SevenZip.DefaultArgs) != len(original.SevenZip.DefaultArgs) {
		t.Errorf("DefaultArgs len = %d, want %d", len(loaded.SevenZip.DefaultArgs), len(original.SevenZip.DefaultArgs))
	}
}



func TestPasswordLength_InvalidMin(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	cfg := &Config{
		General: GeneralConfig{
			KdbxPath:       "/test.kdbx",
			DefaultGroup:   "Test",
			PasswordLength: 8, // Below minimum
		},
		SevenZip: SevenZipConfig{
			BinaryPath: "7z",
		},
	}

	if err := SaveConfig(cfg); err != nil {
		t.Fatalf("SaveConfig() failed: %v", err)
	}

	resetViper(t)

	_, err := LoadConfig()
	if err == nil {
		t.Fatal("LoadConfig() should fail for PasswordLength < 32")
	}
}

func TestPasswordLength_InvalidMax(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	cfg := &Config{
		General: GeneralConfig{
			KdbxPath:       "/test.kdbx",
			DefaultGroup:   "Test",
			PasswordLength: 999, // Above maximum
		},
		SevenZip: SevenZipConfig{
			BinaryPath: "7z",
		},
	}

	if err := SaveConfig(cfg); err != nil {
		t.Fatalf("SaveConfig() failed: %v", err)
	}

	resetViper(t)

	_, err := LoadConfig()
	if err == nil {
		t.Fatal("LoadConfig() should fail for PasswordLength > 128")
	}
}

func TestPasswordLength_ValidValues(t *testing.T) {
	values := []int{
		PasswordLengthMin,
		PasswordLengthDefault,
		PasswordLengthMax,
		48,
		100,
	}

	for _, v := range values {
		resetViper(t)

		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		cfg := &Config{
			General: GeneralConfig{
				KdbxPath:       "/test.kdbx",
				DefaultGroup:   "Test",
				PasswordLength: v,
			},
			SevenZip: SevenZipConfig{
				BinaryPath: "7z",
			},
		}

		if err := SaveConfig(cfg); err != nil {
			t.Fatalf("SaveConfig() failed for length %d: %v", v, err)
		}

		resetViper(t)

		loaded, err := LoadConfig()
		if err != nil {
			t.Fatalf("LoadConfig() failed for length %d: %v", v, err)
		}

		if loaded.General.PasswordLength != v {
			t.Errorf("PasswordLength = %d, want %d", loaded.General.PasswordLength, v)
		}
	}
}

func TestPasswordLength_ZeroDefaultsToConfigDefault(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Save config with 0 password length (not explicitly set)
	cfg := &Config{
		General: GeneralConfig{
			KdbxPath:       "/test.kdbx",
			DefaultGroup:   "Test",
			PasswordLength: 0,
		},
		SevenZip: SevenZipConfig{
			BinaryPath: "7z",
		},
	}

	if err := SaveConfig(cfg); err != nil {
		t.Fatalf("SaveConfig() failed: %v", err)
	}

	resetViper(t)

	loaded, err := LoadConfig()
	if err != nil {
		t.Fatalf("LoadConfig() failed: %v", err)
	}

	// 0 is default, so it should be set to PasswordLengthDefault
	if loaded.General.PasswordLength != PasswordLengthDefault {
		t.Errorf("PasswordLength = %d, want %d (default from 0)", loaded.General.PasswordLength, PasswordLengthDefault)
	}
}

func TestSaveConfig_CreatesDirectoryStructure(t *testing.T) {
	resetViper(t)

	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	cfg := &Config{
		General: GeneralConfig{
			KdbxPath:       "/test.kdbx",
			DefaultGroup:   "Test",
			PasswordLength: PasswordLengthDefault,
		},
		SevenZip: SevenZipConfig{
			BinaryPath: "7z",
		},
	}

	if err := SaveConfig(cfg); err != nil {
		t.Fatalf("SaveConfig() failed: %v", err)
	}

	configDir := filepath.Join(tmpHome, ".config", "7zkpxc")
	info, err := os.Stat(configDir)
	if err != nil {
		t.Fatalf("Config directory not created: %v", err)
	}
	if !info.IsDir() {
		t.Errorf("Expected %s to be a directory", configDir)
	}
}

func TestConstants(t *testing.T) {
	if PasswordLengthMin > PasswordLengthDefault {
		t.Errorf("Min (%d) > Default (%d)", PasswordLengthMin, PasswordLengthDefault)
	}
	if PasswordLengthDefault > PasswordLengthMax {
		t.Errorf("Default (%d) > Max (%d)", PasswordLengthDefault, PasswordLengthMax)
	}
	if PasswordLengthMin < 1 {
		t.Errorf("Min (%d) should be at least 1", PasswordLengthMin)
	}
}
